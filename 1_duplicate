def classify_flag_against_criteria_strict(flag: str, criteria_definitions: Dict[str, str], 
                                 previous_year_data: str, llm: AzureOpenAILLM) -> Dict[str, str]:
    """Strictly classify a single flag against 15 criteria - only High if exact match found"""
    
    # Create strict keyword mapping for each criteria
    criteria_keywords = {
        "debt_increase": ["debt increase", "debt increased", "debt rising", "debt growth", "higher debt", "debt went up"],
        "provisioning": ["provision", "write-off", "write off", "writeoff", "bad debt", "impairment"],
        "asset_decline": ["asset decline", "asset fall", "asset decrease", "asset value down", "asset reduction"],
        "receivable_days": ["receivable days", "collection period", "DSO", "days sales outstanding"],
        "payable_days": ["payable days", "payment period", "DPO", "days payable outstanding"],
        "debt_ebitda": ["debt to ebitda", "debt/ebitda", "debt ebitda ratio", "leverage ratio"],
        "revenue_decline": ["revenue decline", "revenue fall", "revenue decrease", "sales decline", "top line decline"],
        "onetime_expenses": ["one-time", "onetime", "exceptional", "extraordinary", "non-recurring"],
        "margin_decline": ["margin decline", "margin fall", "margin pressure", "margin compression", "profitability decline"],
        "cash_balance": ["cash decline", "cash decrease", "cash balance fall", "liquidity issue"],
        "short_term_debt": ["short-term debt", "current liabilities", "working capital", "short term borrowing"],
        "management_issues": ["management change", "leadership change", "CEO", "CFO", "resignation", "departure"],
        "regulatory_compliance": ["regulatory", "compliance", "regulation", "regulator", "legal", "penalty"],
        "market_competition": ["competition", "competitive", "market share", "competitor", "market pressure"],
        "operational_disruptions": ["operational", "supply chain", "production", "manufacturing", "disruption"]
    }
    
    criteria_list = "\n".join([f"{i+1}. {name}: {desc}" for i, (name, desc) in enumerate(criteria_definitions.items())])
    
    prompt = f"""
You are a strict financial risk classifier. Follow these EXACT rules:

RED FLAG TO CLASSIFY: "{flag}"

CRITERIA DEFINITIONS:
{criteria_list}

PREVIOUS YEAR DATA:
{previous_year_data}

STRICT CLASSIFICATION RULES:
1. Check if the red flag contains EXACT keywords related to any of the 15 criteria
2. If NO exact keyword match is found → MUST classify as "Low"
3. If exact keyword match is found → check if it meets the threshold (30%, 25%, 3x, etc.)
4. Only classify as "High" if BOTH conditions are met:
   - Exact keyword match found
   - Threshold criteria is met based on previous year data

KEYWORDS TO LOOK FOR:
- debt_increase: debt increase, debt increased, higher debt
- provisioning: provision, write-off, impairment  
- asset_decline: asset decline, asset fall, asset decrease
- revenue_decline: revenue decline, sales decline, top line decline
- margin_decline: margin decline, margin pressure, profitability decline
- management_issues: management change, CEO, CFO, resignation
- regulatory_compliance: regulatory, compliance, regulation, penalty
- operational_disruptions: operational, supply chain, production disruption
- And so on...

DEFAULT: If no exact keyword match → Risk_Level: Low

OUTPUT FORMAT (strictly follow):
Matched_Criteria: [exact criteria name if found, otherwise "None"]
Risk_Level: [High only if keyword match AND threshold met, otherwise Low]
Reasoning: [Brief explanation of keyword match and threshold check]
"""
    
    response = llm._call(prompt, max_tokens=300, temperature=0.0)  # Use temperature 0 for consistency
    
    result = {
        'matched_criteria': 'None',
        'risk_level': 'Low',  # Default to Low
        'reasoning': 'No exact keyword match found for any criteria'
    }
    
    lines = response.strip().split('\n')
    for line in lines:
        if line.startswith('Matched_Criteria:'):
            matched = line.split(':', 1)[1].strip()
            result['matched_criteria'] = matched if matched != "None" else 'None'
        elif line.startswith('Risk_Level:'):
            risk_level = line.split(':', 1)[1].strip()
            # Force to Low if no criteria matched
            if result['matched_criteria'] == 'None':
                result['risk_level'] = 'Low'
            else:
                result['risk_level'] = risk_level if risk_level in ['High', 'Low'] else 'Low'
        elif line.startswith('Reasoning:'):
            result['reasoning'] = line.split(':', 1)[1].strip()
    
    return result


def generate_strict_high_risk_summary(high_risk_flags: List[str], context: str, llm: AzureOpenAILLM) -> List[str]:
    """Generate VERY concise 1-2 line summaries for high risk flags using original PDF context"""
    concise_summaries = []
    
    for flag in high_risk_flags:
        prompt = f"""
Based on the original PDF context, create a VERY concise 1-2 line summary for this high risk flag.

ORIGINAL PDF CONTEXT:
{context}

HIGH RISK FLAG: "{flag}"

INSTRUCTIONS:
1. Create EXACTLY 1-2 lines (maximum 2 sentences)
2. Use ONLY information from the original PDF context
3. Include specific numbers/percentages if mentioned in context
4. Be factual and direct
5. Do NOT exceed 2 lines

OUTPUT: [1-2 line summary only]
"""
        
        try:
            response = llm._call(prompt, max_tokens=150, temperature=0.1)
            
            # Clean response and ensure max 2 lines
            summary_lines = [line.strip() for line in response.strip().split('\n') if line.strip()]
            
            if len(summary_lines) > 2:
                # Take first 2 lines only
                concise_summary = '. '.join(summary_lines[:2])
            elif len(summary_lines) == 0:
                # Fallback
                concise_summary = f"{flag}. Requires management attention."
            else:
                concise_summary = '. '.join(summary_lines)
            
            # Ensure it ends with period
            if not concise_summary.endswith('.'):
                concise_summary += '.'
                
            concise_summaries.append(concise_summary)
            
        except Exception as e:
            # Fallback
            concise_summaries.append(f"{flag}. Review required based on analysis.")
    
    return concise_summaries


# Also update the main processing function to use the strict classifier:
def process_pdf_with_strict_classification(pdf_path: str, queries_csv_path: str, previous_year_data: str, 
                               output_folder: str = "results", 
                               api_key: str = None, azure_endpoint: str = None, 
                               api_version: str = None, deployment_name: str = "gpt-4.1-mini"):
    """
    Process PDF with STRICT classification - only High if exact criteria match
    """
    
    # ... (keep all existing code until Step 3: Classify each flag)
    
    # Step 3: Classify each flag with STRICT rules
    classification_results = []
    high_risk_flags = []
    low_risk_flags = []
    
    if len(unique_flags) > 0:
        for i, flag in enumerate(unique_flags, 1):                
            try:
                # Use the STRICT classification function
                classification = classify_flag_against_criteria_strict(
                    flag=flag,
                    criteria_definitions=criteria_definitions,
                    previous_year_data=previous_year_data,
                    llm=llm
                )
                
                classification_results.append({
                    'flag': flag,
                    'matched_criteria': classification['matched_criteria'],
                    'risk_level': classification['risk_level'],
                    'reasoning': classification['reasoning']
                })
                
                # Only add to high risk if explicitly classified as High
                if classification['risk_level'].lower() == 'high' and classification['matched_criteria'] != 'None':
                    high_risk_flags.append(flag)
                else:
                    low_risk_flags.append(flag)
                        
            except Exception as e:
                print(f"    Error classifying flag: {e}")
                # Always default to low risk if classification fails
                classification_results.append({
                    'flag': flag,
                    'matched_criteria': 'None',
                    'risk_level': 'Low',
                    'reasoning': f'Classification failed: {str(e)}'
                })
                low_risk_flags.append(flag)
                
            time.sleep(0.5) 
    
    print(f"STRICT Classification Results:")
    print(f"  High Risk: {len(high_risk_flags)} flags")
    print(f"  Low Risk: {len(low_risk_flags)} flags")
    print(f"  High Risk Flags: {high_risk_flags}")
    
    # ... (rest of the function remains the same)
